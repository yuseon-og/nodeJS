-------------------- 서버 만들고 실행 --------------------
  - npm init
  - npm install express
  - server.js 만들고 express = require('express') 하고 app = express()
  - app.listen(포트번호,할일)

--------------------GET 요청(서버에서 데이터 가져올때)--------------------
  -app.get("경로",하는일(요청, 응답){
      할일
  })


 HTTP 요청 시스템 : ** 경로와 요청방식이 둘다 있어야 서버에서 알아먹고 동작함**
 - GET : 읽기 뭔가 읽고싶을때
   -> '/경로' 들어갔을때 app.get동작으로 데이터 가져오기
       result에 데이터가 담기니 그것을 html/ejs에 넘겨주기
       
 - POST : 쓰기 뭔가 생성할때
   -> html/ejs에서 form 태그에서 action에 '/경로'주고 method에서 post했을때
      server쪽에서는 app.post('/경로') POST 동작이 실행됨

 - PUT : 수정 뭔가 수정할때
 - DELETE : 삭제 뭔가 삭제할때
   -> ajax나 axios로 프론트엔드(html)에서 delete 요청
   server에서 app.delete('/경로')로 Delete 동작이 실행됨

 Post 하기 위해서는
 1. html form 태그에 action = '/경로' method = "POST"
 2. 각각 input에 name 설정 필요(구별하기 위함)
 3. app.post 쓰기 위해서 app.use(express.urlencoded({ extended: true })); 설정
 4. form 태그에 의해서 오는 데이터 정보는 request안에 있음
 5. request.body.name 하면 접근 가능


** GET,POST,DELETE,PUT 동작할때 경로와 요청방식 둘다 있어야 하는데
  app.get(경로,(요청,응답)=>{
     동작 동작 동작
  }) 
  이렇게 돌때 response 즉 응답은 여러가지 방법이 있다.
   - 응답.send('<p>some html</p>') 
      -> 간단한 문자나 html 전송

   - 응답.status(404).send('Sorry, we cannot find that!')
      -> 응답코드 보내고 문자 보내기

   - 응답.sendFile('/uploads/logo.png')
      -> static(정적인) 파일을 보낼수 있다. 
      
   - 응답.render('list.ejs', { ejs에 보낼 데이터 })
      -> render는 ejs등 템플릿이 적용된 페이지 랜더링 해줌
   
   - 응답.json(제이슨데이터)
      -> 제이슨 데이터 담아보낼수 있음




 --------------------API란?--------------------
 REST하게 API짜는게 좋다.
 API : Application Programming Interface
 웹개발 환경에서 API는: 웹서버와 클라이언트 간의 소통 방법
 어떻게 해야 서버랑 통신을 할 수 있을까
                       
 이 API를 어떻게 짜야 REST 하게 짤수 있을까

** REST 원칙 6개
1. Uniform Interface(이게 제일제일 중요해)

인터페이스는 일관성이 있어야한다는 소리가… 뭔소리냐면 
– 하나의 URL로는 하나의 데이터를 가져와야함 (하나를 가져오기 위한 두개의 URL을 만들지 말자)
– 간결하고 예측가능하게 짜세요 (URL 하나를 알면 둘을 알게)
– URL 이름짓기 관습을 잘 따라주세요

좋은 이름짓기 관습
-> url만보고도 예측이 가능해야해
-> URL을 명사로 작성
-> 하위문서 나타낼때는 /
-> 파일확장자 쓰지말것
-> 띄어쓰기는 대시(-)이용
-> 자료하나당 하나의 URL
 

(참고)
다른 곳에서 URL 대신 URI 이런 용어를 많이 쓰기도 하는데 
URI는 자료를 넘버링하고 분류하고 지칭하는 방법이라 보시면 됩니다. URL과 비슷하지만 조금 더 큰 의미입니다. 
도서관에서 책 분류할 때 URI에 의해서 분류하기도 합니다. 

 
2. Client-server 역할 구분하기
서버는 응답만, 클라이언트(브라우저)는 요청만
고객들은 그냥 URL 하나만 알면 서버에 있는 자료를 갖다쓸 수 있습니다. 
고객에게 서버역할을 맡기거나
고객에게 DB에 있는 자료를 직접 꺼내라고 하든지 그런 식으로 코드를 짜시면 안됩니다. 

3. Stateless
요청들은 각각 독립적으로 처리되어야합니다. 
요청1이 성공해야 요청2를 보내주고 그런 식으로 요청간의 의존성이 존재하는 코드를 짜시면 안됩니다. 
다르게 말하면
요청하나 만으로 자료를 가져오기 충분하도록 
요청에 필요한 모든 정보들을 실어 보내는게 좋다는 뜻이겠죠? 
 
4. Cacheable(크롬이 알아서 해줌)
요청을 통해 보내는 자료들은 캐싱이 가능해야합니다.
그리고 캐싱가능하다고 표시하거나 캐싱 기간을 설정해주어야 한다고 합니다.

* 캐싱이뭐냐면
네이버를 방문하면 크롬 브라우저는 자동으로 자주 사용하는 이미지 파일, CSS 파일 등을 하드에 저장해놓습니다. 
별로 바뀔일 없는 네이버 로고나 아이콘 같은거요.
하드에 저장해놓고 네이버 방문할 때 네이버서버에 네이버 로고주세요~라고 요청하지 않고 하드에서 불러옵니다.
이 행위를 캐싱이라고 합니다. 

5. Layered System(안중요해)
요청처리하는곳, DB에 저장하는곳 이런 여러가지 단계를 거쳐서 요청을 처리해도 됩니다.
멋있게 말하면 여러개의 레이어를 거쳐서 요청을 처리하게 만들어도 된다고 합니다.
우리도 그렇게 할 것입니다.

6. Code on Demand(안중요해)
서버는 고객에게 실제 실행가능한 코드를 전송해줄 수도 있습니다. 


------------------------ 웹사이트 기능 만들기 기본------------------------
1. 서버로 데이터 전송할 수 있는 UI 만들기
2. 서버에서 원하는데로 정보를 처리

------------------------DataBase 기본----------------------------
1. Sql : 관계형 데이터베이스 3차원 데이터 넣기 어려워
2. NoSql : Objext 자료형으로 입출력 가능
   Dynamo, Oracle NoSQL, MongoDB, Redis, Cassandra

----------------------------MongoDB 관련--------------------------------
1. MongoDB atlas 가입
2. free 부분 가입
3. 클러스터 만들때 물리적으로 가장 가까운곳 선택
4. 다 만들어지면 Database Access에서 아이디 비번 설정(유저)
  ** MongoDB DataBase Access
    ID : admin
    PW : admin1234
5. Network Access에서 접속할수있는 IP설정
   - 아무곳에서나 접속가능하도록 함 0.0.0.0/0

6. Cluster에서 Connect해야함
   connect -> connect your application
   언어와 버전 선택
   아래의 코드가 가장 중요하다

   mongodb+srv://admin:<password>@cluster0.gbnj2.mongodb.net/myFirstDatabase?retryWrites=true&w=majority

7. npm install mongodb 하고 MongoClient.connect 쓸것

8. collection 설정
      - DataBase는 폴더 / collection은 각 파일들
      - add my own data
      - 변수(db) 선언하고 db = client.db("todoapp"); -> 변수 db는 이제 todoapp에 접근한것임
      - 그다음 db.collection으로 collection에 데이터 넣기 할수 있음

9. collection에 접근하여 데이터 저장
   - 변수.collection('collection이름').insertOne({데이터},(error, result)=>{
      error 났을때 뭐 보여줄래
      저장 성공했을때 뭐보여줄래
   })

10. collection에 접근하여 데이터 가져오기 find()
   - 변수.collection('collection이름').find()
    그리고 모든 데이터를 다 받아와서 배열에 저장해야해
    - 변수.collection('collection이름').find().toArray((error, result)=>{
       해야할 동작
    })
    - 이렇게 받아온 result를 ejs안에 꽂아 넣을수 있어야 한다.

**** get이든 post든 반드시 응답.send( ) 이부분은 반드시 존재해야 한다.

11. _id 값은 항상 있어야 한다 하드코딩은 안된다. 당연히
   - 게시물에 id를 넣는다면 : 총개시물 개수 +1을 해주면 됨
   - 총 게시물 개수??? -> auto increment라는 기능 but mongo DB에는 없는 기능 ㅠㅠ
   - 글 번호는 유니크하게 관리해야함

   -> 하는법 글번호 id를 따로 관리하기 위해서 collection을 추가로 만듦
      counter 라는 collection 만들고 거기에 totalPost : 0, name : "개시물 갯수" 
      여기에 게시물을 하나 발행할때마다 totalPost 부분을 1씩 증가 시킬것임

   -> post 할때 id 부여 할수있도록 하는법
     1) db.collection에서 counter 먼저 열어서 findOne으로 찾는다. findOne({찾는거},콜백함수(error, result))
     2) result.totalPost로 총 게시물 수를 받아서 변수(WOW)에 넣는다.
     3) db.collection('post')를 열어서 데이터 저장을 시작한다
     4) 이때 _id에 변수(WOW)를 넣어주고, 나머지 데이터를 넣어준다
     5) db.collection('post') 닫고나서 db.collection('counter')안에 totalPost도 1을 증가시켜야 한다.

   -> totalPost 증가시키는법 db.collection('count').updateOne({어떤데이터를},{이렇게 수정해줘}, 콜백함수없어도 되긴함)
     1) 수정할때 쓸수있는 함수 updateOne(한개) updateMany(마니)
     2) 기본사용 : 첫번째 자료를 찾아야해 유일한놈(name)으로
                   두번째 $set:{totalPost:1} 이거는 걍 1로 바꿔버리는거
                          $inc:{totalPost:1} 이거는 1을 증가시키는거
                   세번째 : 콜백함수로 error, result 설정해줘 !! 없어도 동작은 잘됨!!

      ** update 류의 함수를 쓸때는 수정값 부분에 { 오퍼레이터 : {키 : 벨류}}하면 됨
      몽고DB에서 가장 어려운 거래.... operator 는 $set, $inc, $rename 등등 찾아서 사용

   

12. 게시글 발행기능 총정리
   0) db선언하고 db와 connect해서 db.collection 쓸수있게 해놓기
   
   1) write.html에서 (ejs일수도 있겠지?) form 태그에 action = "/경로" method="POST" 설정
   
   2) form 태그 안에 input에 name 각각 설정
      -> 일케하면 submit 했을때 action의 경로로 POST 방식으로 input의 name이름으로 데이터가 날라감
   
   3) 데이터 날라오니까 server.js에서는 받아서 처리해줘야해
   
   4) POST로 날려주니까 app.post로 받아주고, 경로는 action에서 설정한 '/경로'를 정해주면 form에서 보낸 데이터 오겠지
   
   5) 콜백함수에는 (request, response)로 파라메터 설정해주고 함수를 크게 열어서 db가지고 지지고 볶고 다해야함
       request(요청)에는 날라온 데이터가 들어있어
       response(응답)은 뭐 어떻게 반응 해주까 하는것(팝업을띄워, 리다이렉트를해 등등)
   
   6) 그 다음 counter collection을 먼저 받아오자
      - findOne으로 counter에 name이 "특정한것"인놈을 찾아와
      - 콜백함수는 error와 result로 result.totalPost하면 counter 값 접근가능
      - 이 카운터값을 별도로 선언한 변수(idCounter)에다 담아놔
      ** 아직 5) 콜백함수 내부임
   
   7) 그리고 이제 post collection에 데이터를 저장하자 
       중요중요!!!!!!! 아직 열려있는 counter collection안에서 해야한다 
         why? totalPost의 값을 받아온 변수 idCounter가 지역변수니까 살아있는 scope 안에서 데이터 저장해야헤
      - post collection 열어주고 insertOne으로 한개를 넣어줍시다.
      - 넣어주는건 {_id:idCount변수, title:request.body.title, date : request.body.date} 이렇게
          아직 5)콜백함수 내부여야만 request로 아까 form에서 POST 방식으로 넘어온 데이터 쓸수있어
      - 콜백함수로 넣고나서 할 동작 error와 result로 정해주기
      ** 아직 5) 콜백함수 내부임 + 6)의 콜백함수 내부임

    8) post collection열여 있는 상태로 아까 counter collection의 totalPost를 변경(update)해주자
      - 아직 5)와 6) 콜백함수 내부인데 7) 콜백함수 내부에서 counter collection 열어서 update 하자
      - .updateOne 함수를 사용
      - .updateOne({특정한거 찾아},{이렇게 바꿔},콜백함수(error, result))
         첫번째 파라메터 : {특정한거 찾아} 아까 6)과 동일
         두번째 파라메터 : {이렇게 바꿔} 요놈이 어려움
           바꾸는 방법 {$오퍼레이터:{어떤키값을 : 일케바꿔요}}
           $오퍼레이터는 다양함, 예시 : $set 아예 값을바꿔요 $inc 바꾸라는것만큼 증가시켜요
         세번째 파라메터 : 항상있는 콜백함수 에러처리





-------------------ejs 셋팅 관련----------------------
    ejs는 node.js에서 view 부분을 담당하는 것으로 html을 그려주는 역할
    html 사이에서 js 문법으로 변화를 줄때 사용

    왜 사용하는가?? : 그냥 html을 사용하면 정적인 페이지가 된다.
    그래서 EJS나 Pug 같은 템플릿 엔진을 사용 즉 서버의 데이터를html에 
    쉽게 박아넣을수 있도록 하는 랜더링 엔진

셋팅하는법
1. npm install ejs

2. server.js에서 app.set('view engine','ejs') -> view 엔진으로 ejs를 사용하겠다 선언

3. 보여주는 파일을 XXX.ejs로 만들기(html이랑 같은 파일이지만 서버데이터를 넣을 수 있다.)



    <%   %> if나 반복문 같은거 적용할때 사용
    <%= 서버에서 보낸 데이터 변수명 %>
    <%-  %>


4. ejs 파일을 보여주는 법
  - app.get('/list',(요청,응답)=>{
     응답.render('list.ejs') -> 이렇게 쓰면 list.ejs 파일을 렌더링해서 보여줌

     ** find().toArray()로 result를 받아왔고, 이것을 ejs 파일에 넘겨줘서 랜더링 시키려면
     응답.render('랜더링할 ejs 파일',{이름 : result})로 넘겨준다
      즉 "랜더링할 ejs파일에다가 디비에서 받아온 result를 "이름"이라는 이름으로 넘겨주이소

  })

5. 이때 ejs 파일은 위치가 매우 중요하다 무조건 views 폴더 내에 위치해야한다.

- JS 반복문 연습

for(let i=0; i<이름.length; i++){
   반복할 코드
}
이 반복문을 ejs 안에서 쓰려면 <%    %>이 안에 써야한다

-------------------- 삭제 DELETE 기능 관련----------------------
!!! form 태그의 method는 GET과 POST 요청 밖에 안된다.... DELETE / PUT 불가능
 해결방법
 1. 라이브러리 method-override 이용(node에서 쓸수 있는) -> form에서 DELETE 가능해짐
 2. Ajax이용(언젠간 쓸꺼니까 이거 꼭 다뤄야하니 이거쓰자)

 Ajax란?
   프론트 엔드에서 자바스크립트로 서버에 요청할수 있는 문법(서버와 통신할 수 있는)
   장점 : 새로고침 없이 해당부분만 변경할수있게 서버랑 통신가능
   ** 그냥 자바스크립트로도 사용가능하지만
      정신건강을 위해서 jquery를 써라
   ** 나중에는 axios를 쓰면 될듯

   - Ajax 사용해서 DELETE 구현하기
      1) html에서 자바스크립트 작성하는법
         - <script>요기다가 작성하면 됨</script>
      
      2)jquery 설치
           <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
            integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
            crossorigin="anonymous"></script>
        부트스트랩에서 이미 jquery 넣어놨다 그러나 slim버전이고 이상한거 붙었다 
         <script src="https://code.jquery.com/jquery-3.5.1.min.js">  </script>
         이렇게 변경해서 cnd 방식으로 설치(구글 검색
         )

      3) jquery 설치 후 어디에서 작업?
         jquery 설치된 script 아래에 작업해야함 반드시~!

      
      4) Ajax 기본문법
          $.ajax({
                   method : 'DELETE',  -> 서버에 새로고침 없이 delete 할꺼야~
                   url : '요청할 경로',
                   data : '요청과 함께 보낼 데이터'   -> 예를들면 게시물번호
                 }).done((결과)=>{
                    요청이 성공하면 여기꺼를 실행해주세요
                    결과가 있어야 하는 요청이면 위에 결과에 있을꺼에요
                 })

      5) server에서 동작은
         app.delete('/경로',(req, res)=>{
            **ajax에서 data를 넘겨보냈으면 req.body에서 확인가능

         })

      5-2)  DELETE 메소드
         db.collection('post').deleteOne({어떤 항목을 찾아서 삭제할래?}, () => {
         요청이 성공하면 해야할일     })
         **** deleteOne(삭제할거, 성공하면 할 행동) -> 여기에서 삭제할거 자료형 맞춰줘야해~!!!
         req.body._id = parseInt(req.body._id)이렇게 int형으로 바꾸어 줄것

      6) 여기까지 하면 새로고침 할때마다 해당 아이디의 글이 삭제된다.
         -> 삭제 버튼을 누를때만 삭제 시켜야해
         -> jquery 문법사용
         $('.delete").click(()=>{
            $.ajax .......
         }) 
           -> 이 문법은 jquery로 "delete"라는 class를 가진 요소를 click하면
           어떠한 동작을 해라 라는 뜻

      7) 어떤 삭제버튼을 눌리면 그 삭제버튼의 글번호(_id)만 삭제되게
         1) ejs로 데이터가 넘어와 있으니 당연히 _id도 있다.
         2) 글번호를 노출시키려면 posts[i]._id 하면 됨
         3) 글번호 노출 안시키려면 태그 속성에다가 data-id="<%=posts[i]._id%>" 하면되
         4) ajax의 data 부분에 {_id : 여기에다가 지금 내가 클릭한 버튼의 id 넣으면되}
         5) $(".delete").click((e)=>{
            let 글번호 = e.target.dataset.id 이러면 태그 속성에 숨겨진 id 가져옴
            ** 궅이 data-id 안해도되 걍 id로 지정하고
            e.target.id 이렇게 잡아도 가능해
         -> 여기까지 하면 server는 동작해서 글을 삭제하는데
            ejs는 새로고침 하기전까지는 그대로 있는디
            그러면 ajax 성공시 
               -> 페이지 강제 새로고침 또는
               -> 삭제버튼 누른 li요소를 안보이게/제거해 주세요
      
      8) 서버에서 요청을 잘 처리했다 / 안했다 안내메세지 줘야해
         -> 서버측에서만 알수 있는것은 X 
            클라이언트에서 알수 있도록 메세지 전송해줘야함
            jQuery로 쓰려면 .fail(function(){
               이 안에다 써주면 됨

            })
         -> 서버에서 먼저 성공 실패 판정부터 시작
            판정하고 서버가 200 / 404보내주면 클라이언트에서
            200이냐 404냐 500이냐에 따라 반응 달리 해주면됨
            서버가 응답으로 status 를 주자 200 / 404 등
            .send로 서버에서 메세지 보내는 방법 사용

      9) 지운거 HTML도 삭제해보자 : 제이쿼리는 새로고침 없이 동작하니까..
               **jQuery에서
                  e.target : 지금 클릭한것
                  this : 지금 이벤트 동작하는곳

            지금누른거.부모님중에("li") 를 찾아주세요
            지금누른거.parent('li').fatdOut() -> 사라지게 해줘요

**** arrow function과 그냥 function에서 $this의 의미가 다르다~!!!!!
         
      10) Detail 페이지 여러개 만들기
         -> app.get("/detail/여기 여러번호) 오도록 만들기
           - /detail/:id   ":id" 이놈으로 무작위 번호 받도록
           - :id 를 쓰면 어떤 값이든 올 수 있고, 이 값은 request.params에 파라메타로 전달된다.
           - 쓰기 위해서는 req.params.id 하면 됨
         -> 어떤 :id 번호가 들어오면 id 번호에 맞는 게시물을 DB에서 찾기
           - db.collection("db이름").findOne({뭘 찾을건지}, (에러, 결과)=>{
              에러 났을때
              결과 났을때 : app.get 함수에 response를 줘야한다.
                    => response.render("ejs파일",{넘겨줄 파라메터})

           })